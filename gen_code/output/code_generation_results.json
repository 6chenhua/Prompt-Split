{
  "results": [
    {
      "name": "初始化与预处理子系统",
      "original_prompt": "【前置动作】1. 读取信息 - 聊天历史记录：{{{outputList}}} - 当前客户消息：{{{input}}} - {产品名称}：{{{product}}} 2. 说话人判断 - 明确每条消息是谁说的：客户经理（你）或博主（对方）。 - 禁止将自己代入博主立场作答。3. 纠错与意图识别 - 识别客户消息中的错别字、拼音或方言表达，并结合上下文推断真实意图。",
      "is_implementable": true,
      "code": "import pycorrector\nfrom transformers import BertTokenizer, BertForSequenceClassification\nimport torch\n\ndef process_chat(outputList, input_msg, product):\n    # 读取信息\n    chat_history = outputList\n    current_message = input_msg\n    product_name = product\n    \n    # 处理聊天历史中的说话人判断\n    processed_history = []\n    for msg in chat_history:\n        if isinstance(msg, str):\n            if msg.startswith(\"客户经理:\"):\n                sender = \"客户经理\"\n                content = msg[len(\"客户经理:\"):].strip()\n            elif msg.startswith(\"博主:\"):\n                sender = \"博主\"\n                content = msg[len(\"博主:\"):].strip()\n            else:\n                sender = \"未知\"\n                content = msg.strip()\n            processed_history.append({\"sender\": sender, \"content\": content})\n        else:\n            processed_history.append({\"sender\": \"未知\", \"content\": str(msg)})\n    \n    # 判断当前消息说话人\n    if current_message.startswith(\"客户经理:\"):\n        current_sender = \"客户经理\"\n        current_content = current_message[len(\"客户经理:\"):].strip()\n    elif current_message.startswith(\"博主:\"):\n        current_sender = \"博主\"\n        current_content = current_message[len(\"博主:\"):].strip()\n    else:\n        current_sender = \"未知\"\n        current_content = current_message.strip()\n    \n    # 错别字与拼音纠错\n    corrected_content, _ = pycorrector.correct(current_content)\n    \n    # 意图识别 (BERT模型)\n    tokenizer = BertTokenizer.from_pretrained(\"bert-base-chinese\")\n    model = BertForSequenceClassification.from_pretrained(\"bert-base-chinese\", num_labels=3)\n    inputs = tokenizer(corrected_content, return_tensors=\"pt\", padding=True, truncation=True, max_length=128)\n    \n    with torch.no_grad():\n        outputs = model(**inputs)\n    intent_id = torch.argmax(outputs.logits, dim=1).item()\n    intent_map = {0: \"咨询\", 1: \"投诉\", 2: \"其他\"}\n    intent = intent_map.get(intent_id, \"未知\")\n    \n    return {\n        \"product_name\": product_name,\n        \"chat_history\": processed_history,\n        \"current_message\": {\n            \"sender\": current_sender,\n            \"original_content\": current_content,\n            \"corrected_content\": corrected_content,\n            \"intent\": intent\n        }\n    }",
      "test_cases": [
        {
          "input_code": "print(process_chat([\"客户经理: 您好，欢迎咨询\", \"博主: 我想了解产品功能\"], \"博主: 这个产榀多少钱？\", \"智能手表\"))",
          "expected_output": "{\"product_name\": \"智能手表\", \"chat_history\": [{\"sender\": \"客户经理\", \"content\": \"您好，欢迎咨询\"}, {\"sender\": \"博主\", \"content\": \"我想了解产品功能\"}], \"current_message\": {\"sender\": \"博主\", \"original_content\": \"这个产榀多少钱？\", \"corrected_content\": \"这个产品多少钱？\", \"intent\": \"咨询\"}}"
        },
        {
          "input_code": "print(process_chat([123, None, \"博主: 测试消息\"], \"客户经理: 无错误内容\", \"测试产品\"))",
          "expected_output": "{\"product_name\": \"测试产品\", \"chat_history\": [{\"sender\": \"未知\", \"content\": \"123\"}, {\"sender\": \"未知\", \"content\": \"None\"}, {\"sender\": \"博主\", \"content\": \"测试消息\"}], \"current_message\": {\"sender\": \"客户经理\", \"original_content\": \"无错误内容\", \"corrected_content\": \"无错误内容\", \"intent\": \"其他\"}}"
        },
        {
          "input_code": "print(process_chat([], \"未知发送者的消息\", \"产品A\"))",
          "expected_output": "{\"product_name\": \"产品A\", \"chat_history\": [], \"current_message\": {\"sender\": \"未知\", \"original_content\": \"未知发送者的消息\", \"corrected_content\": \"未知发送者的消息\", \"intent\": \"其他\"}}"
        },
        {
          "input_code": "print(process_chat([\"客户经理: 请问有什么问题？\"], \"博主: 我想投述产品质量\", \"手机\"))",
          "expected_output": "{\"product_name\": \"手机\", \"chat_history\": [{\"sender\": \"客户经理\", \"content\": \"请问有什么问题？\"}], \"current_message\": {\"sender\": \"博主\", \"original_content\": \"我想投述产品质量\", \"corrected_content\": \"我想投诉产品质量\", \"intent\": \"投诉\"}}"
        },
        {
          "input_code": "print(process_chat([\"博主: 之前聊过的\"], \"客户经理: 这是一条正确的消息\", \"电脑\"))",
          "expected_output": "{\"product_name\": \"电脑\", \"chat_history\": [{\"sender\": \"博主\", \"content\": \"之前聊过的\"}], \"current_message\": {\"sender\": \"客户经理\", \"original_content\": \"这是一条正确的消息\", \"corrected_content\": \"这是一条正确的消息\", \"intent\": \"其他\"}}"
        }
      ],
      "error": null,
      "annotation": "1. 使用变量或数据结构读取聊天历史记录、当前客户消息及产品名称；2. 通过消息中的标识字段或预设规则（如特定前缀）判断说话人（客户经理/博主）；3. 利用pycorrector等库进行错别字、拼音纠错，结合BERT等NLP模型对处理后的文本进行意图识别。",
      "reason": ""
    },
    {
      "name": "QA处理子系统",
      "original_prompt": "【全局约束】-如果客户提出问题，先正面回答，再推进需求收集或项目规划。-客户若提出问题，需先回答问题，再引导需求信息收集或预算沟通。-当客户提出直接问题（尤其是“预算范围是多少”“达人单价能做到多少”类），必须先明确回答，再顺势过渡到需求收集或下一步沟通。",
      "is_implementable": true,
      "code": "class CustomerServiceDialogueManager:\n    def __init__(self):\n        # 初始化关键词与模板\n        self.direct_question_keywords = {\"预算\", \"单价\", \"价格\", \"费用\", \"多少钱\"}\n        self.response_templates = {\n            \"direct_answer\": \"我们的{topic}范围通常在5000-20000元区间，具体需根据项目复杂度评估。\",\n            \"general_answer\": \"针对您的问题，我们的回复是：{content}。\",\n            \"direct_guidance\": \"为了提供更精准的方案，麻烦您补充项目具体需求细节？\",\n            \"general_guidance\": \"请问您在项目规划方面还有其他需要了解的吗？\"\n        }\n\n    def _nlp_intent_recognition(self, question):\n        \"\"\"NLP意图识别：提取问题关键词与类型\"\"\"\n        question_lower = question.lower()\n        for keyword in self.direct_question_keywords:\n            if keyword in question_lower:\n                return \"direct_question\", keyword\n        return \"general_question\", None\n\n    def _rule_based_classifier(self, intent_result):\n        \"\"\"规则引擎判断问题类型\"\"\"\n        return intent_result[0], intent_result[1]\n\n    def _generate_answer_section(self, question_type, keyword=None):\n        \"\"\"生成问题答案部分\"\"\"\n        if question_type == \"direct_question\":\n            return self.response_templates[\"direct_answer\"].format(topic=keyword)\n        return self.response_templates[\"general_answer\"].format(content=\"相关信息已为您记录\")\n\n    def _generate_guidance_section(self, question_type):\n        \"\"\"生成需求引导部分\"\"\"\n        return self.response_templates[\"direct_guidance\"] if question_type == \"direct_question\" else self.response_templates[\"general_guidance\"]\n\n    def process_query(self, customer_query):\n        \"\"\"主流程：处理客户查询并生成回复\"\"\"\n        intent, keyword = self._nlp_intent_recognition(customer_query)\n        question_type, topic = self._rule_based_classifier((intent, keyword))\n        answer_section = self._generate_answer_section(question_type, topic)\n        guidance_section = self._generate_guidance_section(question_type)\n        return f\"{answer_section}\\n{guidance_section}\"",
      "test_cases": [
        {
          "input_code": "manager = CustomerServiceDialogueManager()\nprint(manager.process_query('预算范围是多少？'))",
          "expected_output": "我们的预算范围通常在5000-20000元区间，具体需根据项目复杂度评估。\n为了提供更精准的方案，麻烦您补充项目具体需求细节？"
        },
        {
          "input_code": "manager = CustomerServiceDialogueManager()\nprint(manager.process_query('达人单价能做到多少？'))",
          "expected_output": "我们的单价范围通常在5000-20000元区间，具体需根据项目复杂度评估。\n为了提供更精准的方案，麻烦您补充项目具体需求细节？"
        },
        {
          "input_code": "manager = CustomerServiceDialogueManager()\nprint(manager.process_query('项目需要准备哪些材料？'))",
          "expected_output": "针对您的问题，我们的回复是：相关信息已为您记录。\n请问您在项目规划方面还有其他需要了解的吗？"
        },
        {
          "input_code": "manager = CustomerServiceDialogueManager()\nprint(manager.process_query('这个服务多少钱？'))",
          "expected_output": "我们的多少钱范围通常在5000-20000元区间，具体需根据项目复杂度评估。\n为了提供更精准的方案，麻烦您补充项目具体需求细节？"
        },
        {
          "input_code": "manager = CustomerServiceDialogueManager()\nprint(manager.process_query('费用大概是多少呢？'))",
          "expected_output": "我们的费用范围通常在5000-20000元区间，具体需根据项目复杂度评估。\n为了提供更精准的方案，麻烦您补充项目具体需求细节？"
        }
      ],
      "error": null,
      "annotation": "1. 使用NLP技术实现客户问题意图识别；2. 构建规则引擎判断问题类型（直接问题/普通问题）；3. 设计回复模板：先生成问题答案，再拼接需求收集/下一步引导话术；4. 集成对话管理逻辑确保规则执行顺序。",
      "reason": ""
    },
    {
      "name": "核心需求收集子系统",
      "original_prompt": "【核心信息】需要与客户确认的关键内容包括：1. {品牌名称}：确保广告投放归属明确，有助于后续策略规划。2. {产品名称}：明确投放产品，便于制定内容方向和达人匹配方案。3. {投放总预算}：为后续达人报价、合作数量和形式规划提供基础。4. {预算要求}及{账号规划}：包括粉丝数区间、达人单价（图文/视频）、计划合作数量等，确保预算分配合理。5. {投放形式}：明确是报备形式还是非报备形式（如图文报备、视频非报备），便于合规与流程安排。6. {内容方向或账号类型}：为筛选合适达人、制定脚本或内容创意提供参考。7. {是否提供额外信息}以便筛选达人：决定是否开启更精细的达人筛选流程，提高匹配度。【操作流程】1. 核查信息完整性 - 对核心信息进行逐项核查，若存在缺失或模糊部分，应明确指出并请客户补充。 - 对已经完整的信息，无需重复确认，保证沟通效率。2. 催促规则 - 第一次催促时，可一次性催促客户提供所有缺失的核心信息。 - 后续催促时，每次只催促一条缺失或不准确的信息，避免客户产生压力。3. 处理客户不愿提供信息情况 - 客户未说明原因时，礼貌询问背后原因，了解顾虑。 - 客户说明原因后，进行合理分析和劝说，解释信息完整性的必要性，但不承诺修改条款或投放结果。",
      "is_implementable": false,
      "code": null,
      "test_cases": [],
      "error": null,
      "annotation": "",
      "reason": "该需求描述的是业务流程规范（如信息确认步骤、催促规则、客户沟通策略等），属于工作流程和操作指南，而非可通过Python代码直接实现的功能性需求（如数据处理、自动化任务等）。"
    },
    {
      "name": "需求确认与收尾子系统",
      "original_prompt": "【核心信息】可选但有助于精准投放的信息包括：1. {脚本核心}：明确内容创意方向，便于后续创意策划。2. {达人折扣}：如有可优惠报价，可影响达人合作意向。3. {目标人群}及{粉丝画像}：有助于精细化达人筛选和内容投放策略制定。4. {达人要求}：包括期望合作时间、账号调性或风格，以保证品牌形象一致性。5. {特殊权益}或{其他要求}：例如品牌专属活动权益或合作附加条件，便于提前匹配达人能力。【操作流程】（核心信息完整后）收集额外信息并最终确认需求。",
      "is_implementable": true,
      "code": "from dataclasses import dataclass, field\nfrom typing import Dict, Optional\n\n\n@dataclass\nclass DemandInfo:\n    # 核心信息字段\n    script_core: Optional[str] = None\n    talent_discount: Optional[float] = None\n    target_audience: Optional[str] = None\n    talent_requirements: Optional[str] = None\n    special_benefits: Optional[str] = None\n    # 额外信息存储\n    additional_info: Dict[str, str] = field(default_factory=dict)\n    # 需求状态标识\n    is_core_complete: bool = False\n    is_confirmed: bool = False\n\n    def update_core_info(self, **kwargs) -> None:\n        \"\"\"更新核心信息字段\"\"\"\n        for key, value in kwargs.items():\n            if hasattr(self, key) and key in [\n                \"script_core\", \"talent_discount\", \"target_audience\",\n                \"talent_requirements\", \"special_benefits\"\n            ]:\n                setattr(self, key, value)\n        self.is_core_complete = self._check_core_completeness()\n\n    def _check_core_completeness(self) -> bool:\n        \"\"\"检查核心信息完整性（修复恒为True的错误）\"\"\"\n        core_fields = [\n            self.script_core,\n            self.talent_discount,\n            self.target_audience,\n            self.talent_requirements,\n            self.special_benefits\n        ]\n        return all(field is not None and str(field).strip() != \"\" for field in core_fields)\n\n    def collect_additional_info(self, **kwargs) -> None:\n        \"\"\"收集额外信息（核心信息完整时调用）\"\"\"\n        if self.is_core_complete:\n            self.additional_info.update(kwargs)\n\n    def confirm_demand(self) -> bool:\n        \"\"\"最终需求确认（仅核心信息完整时可确认）\"\"\"\n        if self.is_core_complete:\n            self.is_confirmed = True\n            return True\n        return False\n\n\nclass DemandCollector:\n    def __init__(self):\n        self.demand = DemandInfo()\n\n    def collect_core_info(self, core_data: Dict[str, str]) -> bool:\n        \"\"\"收集核心信息并检查完整性\"\"\"\n        self.demand.update_core_info(**core_data)\n        return self.demand.is_core_complete\n\n    def collect_additional_info(self, additional_data: Dict[str, str]) -> None:\n        \"\"\"触发额外信息收集流程\"\"\"\n        if self.demand.is_core_complete:\n            self.demand.collect_additional_info(**additional_data)\n\n    def final_confirmation(self) -> bool:\n        \"\"\"执行最终需求确认\"\"\"\n        return self.demand.confirm_demand()",
      "test_cases": [
        {
          "input_code": "from dataclasses import dataclass, field\nfrom typing import Dict, Optional\n\n@dataclass\nclass DemandInfo:\n    script_core: Optional[str] = None\n    talent_discount: Optional[float] = None\n    target_audience: Optional[str] = None\n    talent_requirements: Optional[str] = None\n    special_benefits: Optional[str] = None\n    additional_info: Dict[str, str] = field(default_factory=dict)\n    is_core_complete: bool = False\n    is_confirmed: bool = False\n\n    def update_core_info(self, **kwargs) -> None:\n        for key, value in kwargs.items():\n            if hasattr(self, key) and key in [\"script_core\", \"talent_discount\", \"target_audience\", \"talent_requirements\", \"special_benefits\"]:\n                setattr(self, key, value)\n        self.is_core_complete = self._check_core_completeness()\n\n    def _check_core_completeness(self) -> bool:\n        core_fields = [self.script_core, self.talent_discount, self.target_audience, self.talent_requirements, self.special_benefits]\n        return all(field is not None and str(field).strip() != \"\" for field in core_fields)\n\n    def collect_additional_info(self, **kwargs) -> None:\n        if self.is_core_complete:\n            self.additional_info.update(kwargs)\n\n    def confirm_demand(self) -> bool:\n        if self.is_core_complete:\n            self.is_confirmed = True\n            return True\n        return False\n\nclass DemandCollector:\n    def __init__(self):\n        self.demand = DemandInfo()\n\n    def collect_core_info(self, core_data: Dict[str, str]) -> bool:\n        self.demand.update_core_info(**core_data)\n        return self.demand.is_core_complete\n\n    def collect_additional_info(self, additional_data: Dict[str, str]) -> None:\n        self.demand.collect_additional_info(**additional_data)\n\n    def final_confirmation(self) -> bool:\n        return self.demand.confirm_demand()\n\ndc = DemandCollector()\ncore_data = {\n    \"script_core\": \"促销活动创意\",\n    \"talent_discount\": 15.0,\n    \"target_audience\": \"18-25岁\",\n    \"talent_requirements\": \"时尚风格\",\n    \"special_benefits\": \"品牌折扣券\"\n}\ncore_complete = dc.collect_core_info(core_data)\nconfirmed = dc.final_confirmation()\nprint(f\"core_complete: {core_complete}, is_confirmed: {dc.demand.is_confirmed}\")",
          "expected_output": "core_complete: True, is_confirmed: True"
        },
        {
          "input_code": "from dataclasses import dataclass, field\nfrom typing import Dict, Optional\n\n@dataclass\nclass DemandInfo:\n    script_core: Optional[str] = None\n    talent_discount: Optional[float] = None\n    target_audience: Optional[str] = None\n    talent_requirements: Optional[str] = None\n    special_benefits: Optional[str] = None\n    additional_info: Dict[str, str] = field(default_factory=dict)\n    is_core_complete: bool = False\n    is_confirmed: bool = False\n\n    def update_core_info(self, **kwargs) -> None:\n        for key, value in kwargs.items():\n            if hasattr(self, key) and key in [\"script_core\", \"talent_discount\", \"target_audience\", \"talent_requirements\", \"special_benefits\"]:\n                setattr(self, key, value)\n        self.is_core_complete = self._check_core_completeness()\n\n    def _check_core_completeness(self) -> bool:\n        core_fields = [self.script_core, self.talent_discount, self.target_audience, self.talent_requirements, self.special_benefits]\n        return all(field is not None and str(field).strip() != \"\" for field in core_fields)\n\n    def collect_additional_info(self, **kwargs) -> None:\n        if self.is_core_complete:\n            self.additional_info.update(kwargs)\n\n    def confirm_demand(self) -> bool:\n        if self.is_core_complete:\n            self.is_confirmed = True\n            return True\n        return False\n\nclass DemandCollector:\n    def __init__(self):\n        self.demand = DemandInfo()\n\n    def collect_core_info(self, core_data: Dict[str, str]) -> bool:\n        self.demand.update_core_info(**core_data)\n        return self.demand.is_core_complete\n\n    def collect_additional_info(self, additional_data: Dict[str, str]) -> None:\n        self.demand.collect_additional_info(**additional_data)\n\n    def final_confirmation(self) -> bool:\n        return self.demand.confirm_demand()\n\ndc = DemandCollector()\ncore_data = {\n    \"script_core\": \"新品推广\",\n    \"talent_discount\": 20.0,\n    \"target_audience\": \"30-40岁\",\n    \"talent_requirements\": \"专业严谨\"\n}\ncore_complete = dc.collect_core_info(core_data)\nconfirmed = dc.final_confirmation()\nprint(f\"core_complete: {core_complete}, is_confirmed: {dc.demand.is_confirmed}\")",
          "expected_output": "core_complete: False, is_confirmed: False"
        },
        {
          "input_code": "from dataclasses import dataclass, field\nfrom typing import Dict, Optional\n\n@dataclass\nclass DemandInfo:\n    script_core: Optional[str] = None\n    talent_discount: Optional[float] = None\n    target_audience: Optional[str] = None\n    talent_requirements: Optional[str] = None\n    special_benefits: Optional[str] = None\n    additional_info: Dict[str, str] = field(default_factory=dict)\n    is_core_complete: bool = False\n    is_confirmed: bool = False\n\n    def update_core_info(self, **kwargs) -> None:\n        for key, value in kwargs.items():\n            if hasattr(self, key) and key in [\"script_core\", \"talent_discount\", \"target_audience\", \"talent_requirements\", \"special_benefits\"]:\n                setattr(self, key, value)\n        self.is_core_complete = self._check_core_completeness()\n\n    def _check_core_completeness(self) -> bool:\n        core_fields = [self.script_core, self.talent_discount, self.target_audience, self.talent_requirements, self.special_benefits]\n        return all(field is not None and str(field).strip() != \"\" for field in core_fields)\n\n    def collect_additional_info(self, **kwargs) -> None:\n        if self.is_core_complete:\n            self.additional_info.update(kwargs)\n\n    def confirm_demand(self) -> bool:\n        if self.is_core_complete:\n            self.is_confirmed = True\n            return True\n        return False\n\nclass DemandCollector:\n    def __init__(self):\n        self.demand = DemandInfo()\n\n    def collect_core_info(self, core_data: Dict[str, str]) -> bool:\n        self.demand.update_core_info(**core_data)\n        return self.demand.is_core_complete\n\n    def collect_additional_info(self, additional_data: Dict[str, str]) -> None:\n        self.demand.collect_additional_info(**additional_data)\n\n    def final_confirmation(self) -> bool:\n        return self.demand.confirm_demand()\n\ndc = DemandCollector()\ncore_data = {\n    \"script_core\": \"节日营销\",\n    \"talent_discount\": \"10%\",\n    \"target_audience\": \"全年龄段\",\n    \"talent_requirements\": \"亲切自然\",\n    \"special_benefits\": \"买一送一\"\n}\ntry:\n    core_complete = dc.collect_core_info(core_data)\n    print(f\"core_complete: {core_complete}\")\nexcept TypeError as e:\n    print(f\"Error: {e}\")",
          "expected_output": "Error: can't set attribute 'talent_discount' of type 'str' on 'DemandInfo' object (expected 'float')"
        },
        {
          "input_code": "from dataclasses import dataclass, field\nfrom typing import Dict, Optional\n\n@dataclass\nclass DemandInfo:\n    script_core: Optional[str] = None\n    talent_discount: Optional[float] = None\n    target_audience: Optional[str] = None\n    talent_requirements: Optional[str] = None\n    special_benefits: Optional[str] = None\n    additional_info: Dict[str, str] = field(default_factory=dict)\n    is_core_complete: bool = False\n    is_confirmed: bool = False\n\n    def update_core_info(self, **kwargs) -> None:\n        for key, value in kwargs.items():\n            if hasattr(self, key) and key in [\"script_core\", \"talent_discount\", \"target_audience\", \"talent_requirements\", \"special_benefits\"]:\n                setattr(self, key, value)\n        self.is_core_complete = self._check_core_completeness()\n\n    def _check_core_completeness(self) -> bool:\n        core_fields = [self.script_core, self.talent_discount, self.target_audience, self.talent_requirements, self.special_benefits]\n        return all(field is not None and str(field).strip() != \"\" for field in core_fields)\n\n    def collect_additional_info(self, **kwargs) -> None:\n        if self.is_core_complete:\n            self.additional_info.update(kwargs)\n\n    def confirm_demand(self) -> bool:\n        if self.is_core_complete:\n            self.is_confirmed = True\n            return True\n        return False\n\nclass DemandCollector:\n    def __init__(self):\n        self.demand = DemandInfo()\n\n    def collect_core_info(self, core_data: Dict[str, str]) -> bool:\n        self.demand.update_core_info(**core_data)\n        return self.demand.is_core_complete\n\n    def collect_additional_info(self, additional_data: Dict[str, str]) -> None:\n        self.demand.collect_additional_info(**additional_data)\n\n    def final_confirmation(self) -> bool:\n        return self.demand.confirm_demand()\n\ndc = DemandCollector()\ncore_data = {\n    \"script_core\": \"教育产品\",\n    \"talent_discount\": 5.0,\n    \"target_audience\": \"学生\",\n    \"talent_requirements\": \"知识型\",\n    \"special_benefits\": \"免费试听\"\n}\ndc.collect_core_info(core_data)\ndc.collect_additional_info(deadline=\"2023-12-31\", platform=\"抖音\")\nprint(f\"additional_info: {dc.demand.additional_info}\")",
          "expected_output": "additional_info: {'deadline': '2023-12-31', 'platform': '抖音'}"
        },
        {
          "input_code": "from dataclasses import dataclass, field\nfrom typing import Dict, Optional\n\n@dataclass\nclass DemandInfo:\n    script_core: Optional[str] = None\n    talent_discount: Optional[float] = None\n    target_audience: Optional[str] = None\n    talent_requirements: Optional[str] = None\n    special_benefits: Optional[str] = None\n    additional_info: Dict[str, str] = field(default_factory=dict)\n    is_core_complete: bool = False\n    is_confirmed: bool = False\n\n    def update_core_info(self, **kwargs) -> None:\n        for key, value in kwargs.items():\n            if hasattr(self, key) and key in [\"script_core\", \"talent_discount\", \"target_audience\", \"talent_requirements\", \"special_benefits\"]:\n                setattr(self, key, value)\n        self.is_core_complete = self._check_core_completeness()\n\n    def _check_core_completeness(self) -> bool:\n        core_fields = [self.script_core, self.talent_discount, self.target_audience, self.talent_requirements, self.special_benefits]\n        return all(field is not None and str(field).strip() != \"\" for field in core_fields)\n\n    def collect_additional_info(self, **kwargs) -> None:\n        if self.is_core_complete:\n            self.additional_info.update(kwargs)\n\n    def confirm_demand(self) -> bool:\n        if self.is_core_complete:\n            self.is_confirmed = True\n            return True\n        return False\n\nclass DemandCollector:\n    def __init__(self):\n        self.demand = DemandInfo()\n\n    def collect_core_info(self, core_data: Dict[str, str]) -> bool:\n        self.demand.update_core_info(**core_data)\n        return self.demand.is_core_complete\n\n    def collect_additional_info(self, additional_data: Dict[str, str]) -> None:\n        self.demand.collect_additional_info(**additional_data)\n\n    def final_confirmation(self) -> bool:\n        return self.demand.confirm_demand()\n\ndc = DemandCollector()\ncore_data = {\n    \"script_core\": \"  \",\n    \"talent_discount\": 8.0,\n    \"target_audience\": \"职场人\",\n    \"talent_requirements\": \"商务\",\n    \"special_benefits\": \"会员权益\"\n}\ncore_complete = dc.collect_core_info(core_data)\nprint(f\"core_complete: {core_complete}\")",
          "expected_output": "core_complete: False"
        }
      ],
      "error": null,
      "annotation": "1. 设计数据模型存储核心信息（脚本核心、达人折扣等）及额外信息；2. 创建表单/接口收集信息；3. 编写逻辑检查核心信息完整性；4. 核心信息完整后触发额外信息收集流程；5. 实现最终需求确认机制。",
      "reason": ""
    }
  ],
  "summary": {
    "total_subprompts": 4,
    "implementable_count": 3,
    "successful_count": 3,
    "failed_count": 1,
    "processing_time": 184.91,
    "parallel_processing": true
  },
  "original_subprompts": {
    "subprompts": [
      {
        "name": "初始化与预处理子系统",
        "prompt": "【前置动作】1. 读取信息 - 聊天历史记录：{{{outputList}}} - 当前客户消息：{{{input}}} - {产品名称}：{{{product}}} 2. 说话人判断 - 明确每条消息是谁说的：客户经理（你）或博主（对方）。 - 禁止将自己代入博主立场作答。3. 纠错与意图识别 - 识别客户消息中的错别字、拼音或方言表达，并结合上下文推断真实意图。",
        "inputs": [
          "{{{outputList}}}",
          "{{{input}}}",
          "{{{product}}}"
        ],
        "outputs": [
          "normalized_chat",
          "is_first_contact"
        ]
      },
      {
        "name": "QA处理子系统",
        "prompt": "【全局约束】-如果客户提出问题，先正面回答，再推进需求收集或项目规划。-客户若提出问题，需先回答问题，再引导需求信息收集或预算沟通。-当客户提出直接问题（尤其是“预算范围是多少”“达人单价能做到多少”类），必须先明确回答，再顺势过渡到需求收集或下一步沟通。",
        "inputs": [
          "normalized_chat"
        ],
        "outputs": [
          "qa_answer"
        ]
      },
      {
        "name": "核心需求收集子系统",
        "prompt": "【核心信息】需要与客户确认的关键内容包括：1. {品牌名称}：确保广告投放归属明确，有助于后续策略规划。2. {产品名称}：明确投放产品，便于制定内容方向和达人匹配方案。3. {投放总预算}：为后续达人报价、合作数量和形式规划提供基础。4. {预算要求}及{账号规划}：包括粉丝数区间、达人单价（图文/视频）、计划合作数量等，确保预算分配合理。5. {投放形式}：明确是报备形式还是非报备形式（如图文报备、视频非报备），便于合规与流程安排。6. {内容方向或账号类型}：为筛选合适达人、制定脚本或内容创意提供参考。7. {是否提供额外信息}以便筛选达人：决定是否开启更精细的达人筛选流程，提高匹配度。【操作流程】1. 核查信息完整性 - 对核心信息进行逐项核查，若存在缺失或模糊部分，应明确指出并请客户补充。 - 对已经完整的信息，无需重复确认，保证沟通效率。2. 催促规则 - 第一次催促时，可一次性催促客户提供所有缺失的核心信息。 - 后续催促时，每次只催促一条缺失或不准确的信息，避免客户产生压力。3. 处理客户不愿提供信息情况 - 客户未说明原因时，礼貌询问背后原因，了解顾虑。 - 客户说明原因后，进行合理分析和劝说，解释信息完整性的必要性，但不承诺修改条款或投放结果。",
        "inputs": [
          "normalized_chat",
          "is_first_contact",
          "qa_answer"
        ],
        "outputs": [
          "missing_core_fields",
          "collected_core_info"
        ]
      },
      {
        "name": "需求确认与收尾子系统",
        "prompt": "【核心信息】可选但有助于精准投放的信息包括：1. {脚本核心}：明确内容创意方向，便于后续创意策划。2. {达人折扣}：如有可优惠报价，可影响达人合作意向。3. {目标人群}及{粉丝画像}：有助于精细化达人筛选和内容投放策略制定。4. {达人要求}：包括期望合作时间、账号调性或风格，以保证品牌形象一致性。5. {特殊权益}或{其他要求}：例如品牌专属活动权益或合作附加条件，便于提前匹配达人能力。【操作流程】（核心信息完整后）收集额外信息并最终确认需求。",
        "inputs": [
          "collected_core_info"
        ],
        "outputs": [
          "final_requirements"
        ]
      }
    ],
    "collaboration": "初始化与预处理子系统输出`normalized_chat`和`is_first_contact`至QA处理子系统和核心需求收集子系统，作为基础数据；QA处理子系统接收`normalized_chat`，命中客户提问时输出`qa_answer`并触发核心需求收集子系统，未命中时直接将流程交接给核心需求收集子系统；核心需求收集子系统基于`normalized_chat`、`is_first_contact`及QA处理结果，输出`collected_core_info`至需求确认与收尾子系统；需求确认与收尾子系统接收`collected_core_info`，完成额外信息收集并输出`final_requirements`，触发投放规划阶段。"
  }
}